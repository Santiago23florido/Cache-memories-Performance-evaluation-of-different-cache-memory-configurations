\section{Profiling de l’application}

Pour procéder à l’évaluation des configurations de cache pour chacun des algorithmes proposés et analyser leurs performances, il est proposé de réaliser un \emph{profiling} de l’application à l’aide du simulateur gem5. Le \emph{profiling} est essentiel, car il permet de quantifier des éléments du comportement du programme afin de prendre des décisions d’optimisation et de microconception architecturale fondées sur des données, principalement issues de la simulation \cite{Profiling}. Il permet également d’identifier des \emph{hotspots} sur lesquels concentrer la conception et l’optimisation, c’est-à-dire de cibler en priorité les composantes qui contribuent le plus au temps d’exécution. Enfin, il fournit une première approximation de la caractérisation de la charge de travail (\emph{workload}) d’un programme, ce qui facilite l’orientation des choix de conception.


\begin{table}[h]
\centering
\footnotesize
\setlength{\tabcolsep}{3pt}
\resizebox{\linewidth}{!}{%
\begin{tabular}{l|c|c}
\hline
\textbf{Classe} & \textbf{Dijkstra large (A7)} & \textbf{Dijkstra large (A15)} \\
\hline
Lecture (Load) & 45\,516\,963 [28.4] & 45\,905\,506 [28.5] \\
Écriture (Store) & 19\,439\,553 [12.1] & 19\,593\,718 [12.1] \\
Branchement & 43\,904\,570 [21.5] & 44\,122\,872 [21.5] \\
Calcul entier (Int) & 95\,334\,242 [59.5] & 95\,780\,142 [59.4] \\
Calcul flottant (Fp) & 0 [0.0] & 0 [0.0] \\
\hline
\textbf{Total d’instructions exécutées} & \textbf{204\,195\,328} & \textbf{205\,402\,238} \\
\hline
\end{tabular}
}
\caption{Dijkstra large (Cortex-A7 vs Cortex-A15).}
\end{table}

\begin{table}[h]
\centering
\footnotesize
\setlength{\tabcolsep}{3pt}
\resizebox{\linewidth}{!}{%
\begin{tabular}{l|c|c}
\hline
\textbf{Classe} & \textbf{Dijkstra small (A7)} & \textbf{Dijkstra small (A15)} \\
\hline
Lecture (Load) & 10\,313\,882 [28.5] & 10\,474\,419 [28.5] \\
Écriture (Store) & 4\,759\,916 [13.2] & 4\,850\,175 [13.2] \\
Branchement & 9\,823\,729 [21.4] & 9\,978\,854 [21.4] \\
Calcul entier (Int) & 21\,106\,947 [58.3] & 21\,363\,899 [58.2] \\
Calcul flottant (Fp) & 0 [0.0] & 0 [0.0] \\
\hline
\textbf{Total d’instructions exécutées} & \textbf{46\,004\,474} & \textbf{46\,667\,347} \\
\hline
\end{tabular}
}
\caption{Dijkstra small (Cortex-A7 vs Cortex-A15).}
\end{table}

\begin{table}[h]
\centering
\footnotesize
\setlength{\tabcolsep}{3pt}
\resizebox{\linewidth}{!}{%
\begin{tabular}{l|c|c}
\hline
\textbf{Classe} & \textbf{Blowfish (A7)} & \textbf{Blowfish (A15)} \\
\hline
Lecture (Load) & 19\,141 [21.8] & 19\,769 [21.3] \\
Écriture (Store) & 5\,516 [6.3] & 5\,671 [6.1] \\
Branchement & 29\,760 [25.3] & 30\,060 [24.4] \\
Calcul entier (Int) & 63\,342 [72.0] & 67\,560 [72.6] \\
Calcul flottant (Fp) & 0 [0.0] & 0 [0.0] \\
\hline
\textbf{Total d’instructions exécutées} & \textbf{117\,759} & \textbf{123\,060} \\
\hline
\end{tabular}
}
\caption{Blowfish (Cortex-A7 vs Cortex-A15).}
\end{table}

Le \emph{profiling} indique que la classe dominante dans les deux programmes est le calcul entier (\(\approx 60\,\%\) pour Dijkstra et \(\approx 72\,\%\) pour Blowfish) ; ainsi, une micro-architecture disposant de davantage d’ALU entières ou d’un parallélisme accru sur l’entier peut apporter le gain le plus important. Les branchements représentent également une part notable : restructurer les boucles ou réduire les sauts peut donc limiter les pénalités de contrôle. Côté mémoire, Dijkstra est plus sensible car il combine de nombreux accès, souvent irréguliers ; des améliorations de cache et de latence ont donc un impact plus marqué. Blowfish présente généralement des accès plus séquentiels et une meilleure localité : la hiérarchie mémoire aide, mais le goulot principal demeure le \emph{throughput} du calcul entier.


La comparaison montre que, tant pour Dijkstra/SSCA2-BCS que pour le produit de polynômes et Blowfish, le profil d’exécution est fortement dominé par les instructions de calcul : dans Dijkstra et Blowfish, le calcul entier prédomine, tandis que, pour un produit de polynômes implémenté en flottant, on observe une fraction élevée de calcul FP. Par conséquent, une amélioration architecturale transversale consiste à accroître le parallélisme d’exécution dans la classe dominante (davantage d’ALU entières pour les applications entières et davantage d’unités FP si le noyau est flottant), car cette approche cible directement la plus grande proportion d’instructions.

La principale divergence concerne le comportement mémoire. Dijkstra/SSCA2-BCS (graphes) exécute généralement de nombreux \emph{loads/stores} et, surtout, avec des accès irréguliers (dépendants de structures chaînées ou de motifs non linéaires). Cela dégrade la localité, augmente les \emph{miss} en cache et rend les performances très sensibles aux modifications de la hiérarchie mémoire (tailles/associativité des caches, latences, politiques, etc.). À l’inverse, le produit de polynômes et, dans une large mesure, Blowfish présentent des accès plus séquentiels et localisés, ce qui favorise les caches et réduit la pénalité mémoire ; dans ces cas, le goulot d’étranglement se déplace davantage vers le \emph{throughput} de calcul.

Enfin, même si leur poids relatif varie, toutes ces applications peuvent bénéficier d’améliorations du contrôle de flux (branchements) : réduire les sauts via la restructuration des boucles et la simplification des conditions, ou améliorer la prédiction de branchement, diminue les pénalités de mauvaise prédiction et contribue à abaisser le CPI. En synthèse, le meilleur scénario combine (1) davantage de capacité de calcul dans la classe dominante, (2) une optimisation mémoire particulièrement critique pour les graphes, et (3) des améliorations de prédiction/codage apportant des gains additionnels de manière générale.
